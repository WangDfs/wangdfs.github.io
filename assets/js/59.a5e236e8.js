(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{370:function(t,s,v){"use strict";v.r(s);var o=v(4),a=Object(o.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h4",{attrs:{id:"java"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java"}},[t._v("#")]),t._v(" java")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("动态代理")])]),t._v(" "),s("ul",[s("li",[s("p",[t._v("静态代理")])]),t._v(" "),s("li",[s("p",[t._v("JDK动态代理")])]),t._v(" "),s("li",[s("p",[t._v("CGLIB动态代理")])])]),t._v(" "),s("p",[t._v("代理的好处：在不修改原目标对象的情况下对方法进行增强")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("JDK动态代理")])]),t._v(" "),s("p",[s("strong",[t._v("1.在JDK动态代理中，通过Proxy类来创建一个代理对象")])]),t._v(" "),s("p",[s("strong",[t._v("2.有一个InvocationHandler接口来定义一些自定义的逻辑，有一个invoke方法")])]),t._v(" "),s("p",[s("strong",[t._v("3.调用代理对象的某个方法时，其实调用的是InvocationHandler中的invoke方法")])]),t._v(" "),s("p",[s("strong",[t._v("4.因为JDK代理类它也是实现了需要代理对象的接口，并重写了我们代理对象的方法，所以才实现了代理的功能。")])]),t._v(" "),s("hr"),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("CGLIB动态代理")])]),t._v(" "),s("p",[s("strong",[t._v("1.在CGLIB中通过生成代理对象的子类来进行方法的增强")])]),t._v(" "),s("p",[s("strong",[t._v("2.MethodInterceptor接口有一个intercept方法")])]),t._v(" "),s("p",[s("strong",[t._v("3.重写intercept方法用于拦截增强代理类的方法")])]),t._v(" "),s("p",[s("strong",[t._v("4.Enhancer类，通过Enhancer类来创建代理对象")])]),t._v(" "),s("p",[s("strong",[t._v("5.一个private方法， 子类再写一个public的方法并不会重写之前的方法")])])])}),[],!1,null,null,null);s.default=a.exports}}]);