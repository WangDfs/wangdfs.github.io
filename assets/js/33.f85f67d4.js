(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{346:function(n,s,a){"use strict";a.r(s);var i=a(4),t=Object(i.a)({},(function(){var n=this,s=n._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("设有 N 堆石子排成一排，其编号为 1,2,3,…,N\n每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N堆石子合并成为一堆。\n每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和\n例如有 4堆石子分别为 1 3 5 2， 我们可以先合并 1、2 堆，代价为 4，得到 4 5 2， 又合并 1、2 堆，代价为 9，得到 9 2 ，再合并得到 11，总代价为 4+9+11=24；\n如果第二步是先合并 2、3堆，则代价为 7，得到 4 7，最后一次合并代价为 11，总代价为 4+7+11=22\n问题是：找出一种合理的方法，使总的代价最小，输出最小代价。\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br")])]),s("p",[s("strong",[n._v("可以把第i个位置当成分界点， 左边的最小值，和右边的最小值。然后划分为子问题递归求解，或者dp求解")])]),n._v(" "),s("div",{staticClass:"language-c++ line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("#include<iostream>\n#include<algorithm>\n#include<bits/stdc++.h>\nusing namespace std;\nint n, a[310], s[310], f[310][310];\nint solve(int l, int r){\n    if(f[l][r] != -1){\n        return f[l][r];\n    }\n    if(l == r){\n        return f[l][r] = 0;\n    }\n    int res = 1 << 30;\n    for(int i = l; i < r; i++){\n       res = min(res, solve(l, i) + solve(i + 1, r));\n    }\n    return f[l][r] = res + s[r] - s[l - 1];\n}\nint main(){\n\n    cin >> n;\n    for(int i = 1; i <= n; i++){\n        cin >> a[i];\n    }\n    for(int i = 1; i <= n; i++){\n        s[i] = s[i - 1] + a[i];\n    }\n   //cout << solve(1, n);\n    \n    \n   //dp写法\n    memset(f, 127, sizeof(f));\n    for(int i = 1; i <= n; i++){\n        f[i][i] = 0;\n    }\n    for(int i = 1; i < n; i++){ //区间长度\n        for(int j = 1; j <= n - i; j++){ //区间左端点\n            for(int k = j; k < j + i; k++){ //遍历j 到 j + i每个点。\n                f[j][j + i] = min(f[j][j + i], f[j][k] + f[k + 1][j + i] + s[j + i] - s[j - 1]);\n            }\n        }\n    }\n    cout << f[1][n];\n    return 0;\n}\n")])]),n._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[n._v("1")]),s("br"),s("span",{staticClass:"line-number"},[n._v("2")]),s("br"),s("span",{staticClass:"line-number"},[n._v("3")]),s("br"),s("span",{staticClass:"line-number"},[n._v("4")]),s("br"),s("span",{staticClass:"line-number"},[n._v("5")]),s("br"),s("span",{staticClass:"line-number"},[n._v("6")]),s("br"),s("span",{staticClass:"line-number"},[n._v("7")]),s("br"),s("span",{staticClass:"line-number"},[n._v("8")]),s("br"),s("span",{staticClass:"line-number"},[n._v("9")]),s("br"),s("span",{staticClass:"line-number"},[n._v("10")]),s("br"),s("span",{staticClass:"line-number"},[n._v("11")]),s("br"),s("span",{staticClass:"line-number"},[n._v("12")]),s("br"),s("span",{staticClass:"line-number"},[n._v("13")]),s("br"),s("span",{staticClass:"line-number"},[n._v("14")]),s("br"),s("span",{staticClass:"line-number"},[n._v("15")]),s("br"),s("span",{staticClass:"line-number"},[n._v("16")]),s("br"),s("span",{staticClass:"line-number"},[n._v("17")]),s("br"),s("span",{staticClass:"line-number"},[n._v("18")]),s("br"),s("span",{staticClass:"line-number"},[n._v("19")]),s("br"),s("span",{staticClass:"line-number"},[n._v("20")]),s("br"),s("span",{staticClass:"line-number"},[n._v("21")]),s("br"),s("span",{staticClass:"line-number"},[n._v("22")]),s("br"),s("span",{staticClass:"line-number"},[n._v("23")]),s("br"),s("span",{staticClass:"line-number"},[n._v("24")]),s("br"),s("span",{staticClass:"line-number"},[n._v("25")]),s("br"),s("span",{staticClass:"line-number"},[n._v("26")]),s("br"),s("span",{staticClass:"line-number"},[n._v("27")]),s("br"),s("span",{staticClass:"line-number"},[n._v("28")]),s("br"),s("span",{staticClass:"line-number"},[n._v("29")]),s("br"),s("span",{staticClass:"line-number"},[n._v("30")]),s("br"),s("span",{staticClass:"line-number"},[n._v("31")]),s("br"),s("span",{staticClass:"line-number"},[n._v("32")]),s("br"),s("span",{staticClass:"line-number"},[n._v("33")]),s("br"),s("span",{staticClass:"line-number"},[n._v("34")]),s("br"),s("span",{staticClass:"line-number"},[n._v("35")]),s("br"),s("span",{staticClass:"line-number"},[n._v("36")]),s("br"),s("span",{staticClass:"line-number"},[n._v("37")]),s("br"),s("span",{staticClass:"line-number"},[n._v("38")]),s("br"),s("span",{staticClass:"line-number"},[n._v("39")]),s("br"),s("span",{staticClass:"line-number"},[n._v("40")]),s("br"),s("span",{staticClass:"line-number"},[n._v("41")]),s("br"),s("span",{staticClass:"line-number"},[n._v("42")]),s("br"),s("span",{staticClass:"line-number"},[n._v("43")]),s("br"),s("span",{staticClass:"line-number"},[n._v("44")]),s("br"),s("span",{staticClass:"line-number"},[n._v("45")]),s("br")])])])}),[],!1,null,null,null);s.default=t.exports}}]);